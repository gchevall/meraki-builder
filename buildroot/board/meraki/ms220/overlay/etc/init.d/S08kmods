#!/bin/sh
#
# Copyright (C) 2020-2021 - Hal Martin (github.com/halmartin)
#
# Load kernel modules for managing the Vitesse ASIC
#

product_number_to_model() {
    case $1 in
        600-28010|600-28020)
            echo MS220-8
        ;;
        600-20030|600-20040)
            echo MS220-24
        ;;
        600-21030|600-21040|600-21050)
            echo MS220-48
        ;;
        600-20050|600-20060)
            echo MS320-24
        ;;
        600-21060|600-21070)
            echo MS320-48
        ;;
        600-20010|600-20020)
            echo MS22
        ;;
        600-21010|600-21020)
            echo MS42
        ;;
    esac
}

get_board_config_mtd() {
    if [ $(grep -c "board-config" /proc/mtd) -ne 0 ]; then
        grep "board-config" /proc/mtd | awk -F':' '{print $1}' | grep -Eo "[0-9]"
    else
        >&2 echo "board-config not found!"
    fi
}

get_board_cpu() {
    case "$(cat /proc/cpuinfo | grep 'system type' | grep -Eo 'VSC74[23][457]( Dual)?')" in
        "VSC7425")
            echo "MS220-8"
        ;;
        "VSC7427")
            echo "MS220-24"
        ;;
        "VSC7434")
            echo "MS320-24"
        ;;
        "VSC7434 Dual")
            echo "MS320-48"
        ;;
    esac
}

determine_board() {
    # first, try to get the board info from /etc/boardinfo
    if [ -f /etc/boardinfo ]; then
        model=$(grep MODEL /etc/boardinfo | awk -F'=' '{print $2}')
    # next, try to get the board info from the board-config partition on NAND
    elif [ $(grep -c "board-config" /proc/mtd) -ne 0 ]; then
        MTD_PART=$(get_board_config_mtd)
        echo board-config is /dev/mtd${MTD_PART}
        product_number=$(dd if=/dev/mtdblock${MTD_PART} bs=8 skip=1 count=8 2>/dev/null | strings | grep -Eo "600-2[018]0[1-9]0")
        model=$(product_number_to_model $product_number)
        if [ ! -f /etc/boardinfo ]; then
            # persist model in overlayfs
            echo MODEL=${model} > /etc/boardinfo
        fi
    fi

    if [ $(echo $model | grep -c -E "MS[234]2(0-[248]([48])?(P|LP|FP)?)?") -ne 1 ]; then
        # boardinfo didn't have an expected model string, fall back to cpuinfo detection
        # fall back to detection based on cpuinfo, WILL PROBABLY BE WRONG
        model=$(get_board_cpu)
        echo "!!! IMPORTANT !!!"
        echo -n "Falling back to cpuinfo board detection, "
        echo -n "your board model is: ${model}, product: ${product_number} "
        echo "please open an issue on github.com/halmartin/meraki-builder"
        echo "!!! IMPORTANT !!!"
    fi

    # detect the mod_dir and switch_board from boardinfo
    case $model in
        MS220-8)
            mod_dir=luton26
            switch_board=MERAKI_BOARD_MS220_8
            echo 10 > /tmp/NUM_PORTS
        ;;
        MS220-24)
            mod_dir=luton26
            switch_board=MERAKI_BOARD_MS220_24
            echo 24 > /tmp/NUM_PORTS
        ;;
        MS220-48)
            mod_dir=jaguar_dual
            switch_board=MERAKI_BOARD_MS220_48
            echo 52 > /tmp/NUM_PORTS
        ;;
        MS320-24)
            mod_dir=jaguar
            switch_board=MERAKI_BOARD_MS320_24
            echo 24 > /tmp/NUM_PORTS
        ;;
        MS320-48)
            mod_dir=jaguar_dual
            switch_board=MERAKI_BOARD_MS320_48
            echo 52 > /tmp/NUM_PORTS
        ;;
        MS22)
            mod_dir=luton26
            switch_board=MERAKI_BOARD_MS22
            echo 24 > /tmp/NUM_PORTS
        ;;
        MS42)
            mod_dir=jaguar_dual
            switch_board=MERAKI_BOARD_MS42
            echo 52 > /tmp/NUM_PORTS
        ;;
    esac

    export model
    export mod_dir
    export switch_board
}

load_modules() {
    # we have to load vtss_core first
    insmod ${MOD_PATH}/${mod_dir}/vtss_core.ko board_desc=${switch_board}
    if [ $? -ne 0 ]; then
        echo "Error inserting '${mod_dir}/vtss_core.ko board_desc=${switch_board}'" > /dev/kmsg
    else
        echo "Loaded '${mod_dir}/vtss_core.ko board_desc=${switch_board}'"
    fi
    # load the other modules
    modules="proclikefs merakiclick elts_meraki"
    for mod in $modules; do
        insmod ${MOD_PATH}/${mod}.ko
        if [ $? -ne 0 ]; then
            echo "Error inserting ${mod}.ko" > /dev/kmsg
        else
            echo "Loaded '${mod}.ko'"
        fi
        sleep 1
    done
    # vc_click is loaded last
    insmod ${MOD_PATH}/${mod_dir}/vc_click.ko
    if [ $? -ne 0 ]; then
        echo "Error inserting '${mod_dir}/vc_click.ko'" > /dev/kmsg
    else
        echo "Loaded '${mod_dir}/vc_click.ko'"
    fi
}

# copying with bs=1 is slow, calculate the maximum blocksize we can use with dd
largest_blocksize() {
    header_offset=$1
    max_size=1
    for size in $(seq 2 6); do
        if [ $(($header_offset % $((2**$size)))) -eq 0 ]; then
          max_size=$((2**$size))
        else
          break
        fi
    done
    echo $max_size
}

check_and_load() {
    KVER=$(uname -r | awk -F'-' '{print $1}')
    # check the module version
    RD_KVER=$(strings /tmp/lib/modules/${mod_dir}/vtss_core.ko | grep 'vermagic=' | awk -F'=' '{print $2}' | awk -F'-' '{print $1}')
    if [ "$RD_KVER" != "$KVER" ]; then
        echo "$part contains modules for $RD_KVER, but we booted $KVER"
        # clean up modules
        rm -rf /tmp/lib/modules
    else
        echo "Found kernel modules in $part"
        export MOD_PATH=/tmp/lib/modules
        load_modules
        # we loaded the modules, bail
        return
    fi
}

dump_modules() {
    MTD_PART=$(grep ${part} /proc/mtd | awk -F':' '{print $1}' | grep -o '[[:digit:]]*')
    MTD_SIZE=$(grep ${part} /proc/mtd | awk '{print $2}')
    if [ $(df /tmp | tail -1 | awk '{print $4}') -lt $MTD_SIZE ]; then
        # we don't have space in /tmp to dump the ${part}
        echo "Insufficient space in /tmp, using slower dumping method"
        RD_OFFSET=$(find_hdr -g /dev/mtdblock${MTD_PART})
        BLOCK_SIZE=$(largest_blocksize $RD_OFFSET)
        cd /tmp
        dd if=/dev/mtdblock${MTD_PART} bs=$BLOCK_SIZE skip=$(($RD_OFFSET/$BLOCK_SIZE)) | gzip -dc | cpio -idu lib/modules/*.ko lib/modules/${mod_dir}
        RD_KVER=$(strings /tmp/lib/modules/${mod_dir}/vtss_core.ko | grep 'vermagic=' | awk -F'=' '{print $2}' | awk -F'-' '{print $1}')
   fi
   dd if=/dev/mtdblock${MTD_PART} of=/tmp/${part}.bin bs=1M
   RD_OFFSET=$(find_hdr -g /tmp/${part}.bin)
   # no header, skip
   if [ $RD_OFFSET -lt 0 ]; then
       rm /tmp/${part}.bin
   else
       BLOCK_SIZE=$(largest_blocksize $RD_OFFSET)
       # found GZIP header, it's at RD_OFFSET
       dd if=/tmp/${part}.bin of=/tmp/initrd-${part}.gz bs=$BLOCK_SIZE skip=$(($RD_OFFSET/$BLOCK_SIZE))
       rm /tmp/${part}.bin
       # extract the kernel modules from initrd.gz
       cd /tmp && gzip -dc /tmp/initrd-${part}.gz | cpio -idu lib/modules/*.ko lib/modules/${mod_dir}
       rm /tmp/initrd-${part}.gz
   fi
}

fwcutter() {
    # check that the kernel modules exist
    if [ ! -d /lib/modules/${mod_dir} ]; then
        # deploy fwcutter!
        command -v find_hdr
        if [ $? -eq 0 ]; then
            # store current kernel version
            KVER=$(uname -r | awk -F'-' '{print $1}')
            export KVER
            # find the mtd partition
            fw_regions="part1 part2"
            for part in $fw_regions; do
                MTD_PART=$(grep ${part} /proc/mtd | awk -F':' '{print $1}' | grep -o '[[:digit:]]*')
                MTD_SIZE=$(grep ${part} /proc/mtd | awk '{print $2}')
                if [ $(df /tmp | tail -1 | awk '{print $4}') -lt $MTD_SIZE ]; then
                    # we don't have space in /tmp to dump the ${part}
                    echo "Insufficient space in /tmp, using slower dumping method"
                    RD_OFFSET=$(find_hdr -g /dev/mtdblock${MTD_PART})
                    BLOCK_SIZE=$(largest_blocksize $RD_OFFSET)
                    cd /tmp
                    dd if=/dev/mtdblock${MTD_PART} bs=$BLOCK_SIZE skip=$(($RD_OFFSET/$BLOCK_SIZE)) | gzip -dc | cpio -idu lib/modules/*.ko lib/modules/${mod_dir}
                    RD_KVER=$(strings /tmp/lib/modules/${mod_dir}/vtss_core.ko | grep 'vermagic=' | awk -F'=' '{print $2}' | awk -F'-' '{print $1}')
                fi
                dd if=/dev/mtdblock${MTD_PART} of=/tmp/${part}.bin bs=1M
                RD_OFFSET=$(find_hdr -g /tmp/${part}.bin)
                # no header, skip
                if [ $RD_OFFSET -lt 0 ]; then
                    rm /tmp/${part}.bin
                else
                    BLOCK_SIZE=$(largest_blocksize $RD_OFFSET)
                    # found GZIP header, it's at RD_OFFSET
                    dd if=/tmp/${part}.bin of=/tmp/initrd-${part}.gz bs=$BLOCK_SIZE skip=$(($RD_OFFSET/$BLOCK_SIZE))
                    rm /tmp/${part}.bin
                    # extract the kernel modules from initrd.gz
                    cd /tmp && gzip -dc /tmp/initrd-${part}.gz | cpio -idu lib/modules/*.ko lib/modules/${mod_dir}
                    rm /tmp/initrd-${part}.gz
                    # check the module version
                    RD_KVER=$(strings /tmp/lib/modules/${mod_dir}/vtss_core.ko | grep 'vermagic=' | awk -F'=' '{print $2}' | awk -F'-' '{print $1}')
                    if [ "$RD_KVER" != "$KVER" ]; then
                        echo "$part contains modules for $RD_KVER, but we booted $KVER"
                        # clean up modules
                        rm -rf /tmp/lib/modules
                    else
                        echo "Found kernel modules in $part"
                        export MOD_PATH=/tmp/lib/modules
                        load_modules
                        # we loaded the modules, bail
                        return
                    fi
                fi
            done
            echo "Couldn't find kernel modules for $KVER"
        else
            echo "Kernel modules are missing and find_hdr is not present!"
        fi
    else
        # the modules exist in squashfs
        export MOD_PATH=/lib/modules
        load_modules
    fi
}

start() {
    # figure out the switch board
    determine_board
    fwcutter
}

stop() {
    modules="vc_click elts_meraki merakiclick proclikefs vtss_core"
    for mod in $modules; do
        modprobe -r -f $mod
        if [ $? -ne 0 ]; then
            echo "Error removing '${mod}.ko'" > /dev/kmsg
            return
        fi
    done
}

restart() {
    stop
    start
}

case "$1" in
  start)
      start
    ;;
  stop)
      stop
    ;;
  restart|reload)
      restart
    ;;
  *)
    echo "Usage: $0 {start|stop|restart}"
    exit 1
esac

exit $?
